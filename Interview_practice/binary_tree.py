# Q 1. Binary Tree Inorder Traversal
# Given the root of a binary tree, return the inorder traversal of its nodes' values.
# Example 1:
# Input: root = [1,null,2,3]
# Output: [1,3,2]


# Q 2. Binary Tree Preorder Traversal
# Given the root of a binary tree, return the preorder traversal of its nodes'
# values.
# Example 1:
# Input: root = [1,null,2,3]
# Output: [1,2,3]

# Q 3. Unique Binary Search Trees II
# Given an integer n, return the number of structurally unique BST's (binary
# search trees) which has exactly n nodes of unique values from 1 to n.
# Example 1:
# Input: n = 3
# Output: 5

# Q 4. Unique Binary Search Trees II
# Given an integer n, return all the structurally unique BST's (binary search
# trees), which has exactly n nodes of unique values from 1 to n. Return the
# answer in any order.
# Example 1:
# Input: n = 3
# Output: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]

# Q 5. Validate Binary Search Tree
# Given the root of a binary tree, determine if it is a valid binary search tree
# (BST).
# A valid BST is defined as follows:
# • The left subtree of a node contains only nodes with keys less than the
# node's key.
# • The right subtree of a node contains only nodes with keys greater than
# the node's key.
# • Both the left and right subtrees must also be binary search trees.
# Example 1:
# Input: root = [2,1,3]
# Output: true

# Q 6. Symmetric Tree
# Given the root of a binary tree, check whether it is a mirror of itself (i.e.,
# symmetric around its center).
# Example 1:
# Input: root = [1,2,2,3,4,4,3]
# Output: true


# Q 7. Binary Tree Level Order Traversal
# Given the root of a binary tree, return the level order traversal of its nodes'
# values. (i.e., from left to right, level by level).
# Example 1:
# Input: root = [3,9,20,null,null,15,7]
# Output: [[3],[9,20],[15,7]]

# Q 8. Maximum Depth of Binary Tree
# Given the root of a binary tree, return its maximum depth.
# A binary tree's maximum depth is the number of nodes along the longest path
# from the root node down to the farthest leaf node.
# Example 1:
# Input: root = [3,9,20,null,null,15,7]
# Output: 3

# Q 9. Binary Tree Right Side View
# Given the root of a binary tree, imagine yourself standing on the right side of
# it, return the values of the nodes you can see ordered from top to bottom.
# Example 1:
# Input: root = [1,2,3,null,5,null,4]
# Output: [1,3,4]


# Q 10. Kth Smallest Element in a BST
# Given the root of a binary search tree, and an integer k, return the kth smallest
# value (1-indexed) of all the values of the nodes in the tree.
# Example 1:
# Input: root = [3,1,4,null,2], k = 1
# Output: 1

# Q 11. Sum of Left Leaves
# Given the root of a binary tree, return the sum of all left leaves.
# A leaf is a node with no children. A left leaf is a leaf that is the left child of
# another node.
# Example 1:
# Input: root = [3,9,20,null,null,15,7]
# Output: 24

# Q 12. Binary Tree Zigzag Level Order Traversal
# Given the root of a binary tree, return the zigzag level order traversal of its
# nodes' values. (i.e., from left to right, then right to left for the next level and
# alternate between).
# Example 1:
# Input: root = [3,9,20,null,null,15,7]
# Output: [[3],[20,9],[15,7]]


# Q 13. Binary Tree Maximum Path Sum
# A path in a binary tree is a sequence of nodes where each pair of adjacent
# nodes in the sequence has an edge connecting them. A node can only appear
# in the sequence at most once. Note that the path does not need to pass
# through the root.
# The path sum of a path is the sum of the node's values in the path.
# Given the root of a binary tree, return the maximum path sum of any non-
# empty path.
# Example 1:
# Input: root = [1,2,3]
# Output: 6


# Q 14. Search in a Binary Search Tree
# You are given the root of a binary search tree (BST) and an integer val.
# Find the node in the BST that the node's value equals val and return the
# subtree rooted with that node. If such a node does not exist, return null.
# Example 1:
# Input: root = [4,2,7,1,3], val = 2
# Output: [2,1,3]

